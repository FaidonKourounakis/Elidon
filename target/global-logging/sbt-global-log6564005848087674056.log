[0m[[0m[0mdebug[0m] [0m[0m> Exec(collectAnalyses, None, Some(CommandSource(network-1)))[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Processing event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: initialized: JsonRpcNotificationMessage(2.0, initialized, {})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/faido/Documents/My%20Documents/ECE/Semester%206/Advanced%20Computer%20Architecture/Elidon/src/main/scala/Main.scala","languageId":"scala","version":1077,"text":"import chisel3._\r\nimport chisel3.util._\r\n\r\nclass Elidon extends Module {\r\n  val io = IO(new Bundle {\r\n    val leds = Output(UInt(16.W))\r\n    val display = new Bundle {\r\n      val segments = Output(UInt(7.W))\r\n      val selector = Output(UInt(4.W))\r\n    }\r\n    val switches = Input(UInt(16.W))\r\n  })\r\n\r\n  // Initialise Pipeline Stages\r\n  val fetchStage = Module(new FetchStage)\r\n  val decodeStage = Module(new DecodeStage)\r\n  val executeStage = Module(new FetchStage)\r\n  val memoryStage = Module(new MemoryStage)\r\n  val writeBackStage = Module(new WriteBackStage)\r\n\r\n  // Initialise communication of Memory stage with data segment\r\n  val dataMemory = Module(new DataMemory)\r\n  memoryStage.io.data <> dataMemory.io.data\r\n  \r\n  // Connect data memory segment to board IO:\r\n  dataMemory.io.switches := io.switches\r\n  io.leds := dataMemory.io.leds\r\n  val displayMultiplexer = Module(new DisplayMultiplexer)\r\n  displayMultiplexer.io.value := dataMemory.io.displayValue\r\n  io.display := displayMultiplexer.io.display\r\n}\r\n\r\nobject Main extends App {\r\n  (new chisel3.stage.ChiselStage).emitVerilog(new Elidon())\r\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/faido/Documents/My%20Documents/ECE/Semester%206/Advanced%20Computer%20Architecture/Elidon/src/main/scala/empty/PC.scala","languageId":"scala","version":1,"text":"import chisel3._\r\n\r\nclass PC extends Module {\r\n  val io = IO(new Bundle {\r\n    // Clock input to pc\r\n    val clock = Input(Clock()) \r\n    // 1 > normal operation, 0 > resets PC\r\n    val normalOperation = Input(Bool()) \r\n    val sel_a     = Input(Bool()) //\r\n    val sel_imm   = Input(Bool())\r\n    val branch    = Input(Bool())\r\n    val a         = Input(UInt(16.W))\r\n    val d_imm     = Input(UInt(16.W))\r\n    val e_imm     = Input(UInt(16.W))\r\n    val pc_addr   = Input(UInt(16.W))\r\n    val addr      = Output(UInt(16.W))\r\n    val nextAddress = Output(UInt(16.W))\r\n  })\r\n\r\n  val adressReg   = RegInit(0.U(16.W))\r\n  val mux1  = Wire(UInt(16.W))\r\n  val mux2  = Wire(UInt(16.W))\r\n  val mux3  = Wire(UInt(16.W))\r\n\r\n  io.addr      := mux3\r\n  io.nextAddress := addresReg\r\n\r\n  mux1 := Mux(io.branch === false.B, addressReg, io.pc_addr)\r\n  mux2 := Mux(io.branch === false.B, 2.U, io.e_imm + 2.U)\r\n\r\n  when(io.sel_imm === false.B && io.sel_a === false.B) {\r\n    mux3 := mux1 + mux2\r\n  }.elsewhen(io.sel_imm === false.B && io.sel_a === true.B) {\r\n    mux3 := 4.U + io.a\r\n  }.elsewhen(io.sel_imm === true.B && io.sel_a === false.B) {\r\n    mux3 := Cat(io.d_imm(13, 0), 0.U(2.W))\r\n  }.otherwise {\r\n    mux3 := 0.U\r\n  }\r\n\r\n  when(!io.normalOperation) {\r\n    addressReg := 0.U\r\n  }.elsewhen (risingEdge(io.clock)) {\r\n    addressReg := mux3\r\n  }\r\n}\r\n\r\n\r\nclass PC2 extends Module {\r\n  val io = IO(new Bundle {\r\n    // 1 > normal operation, 0 > resets PC\r\n    val normalOperation = Input(Bool())\r\n    val jumpAdress = Input(Uint(16.W))\r\n    val jump = Input(Bool())\r\n    val nextAddress = Output(UInt(16.W))\r\n  })\r\n\r\n  val adressReg   = RegInit(0.U(16.W))\r\n  val mux1  = Wire(UInt(16.W))\r\n  val mux2  = Wire(UInt(16.W))\r\n  val mux3  = Wire(UInt(16.W))\r\n\r\n  io.addr      := mux3\r\n  io.nextAddress := addresReg\r\n\r\n  mux1 := Mux(io.branch === false.B, addressReg, io.pc_addr)\r\n  mux2 := Mux(io.branch === false.B, 2.U, io.e_imm + 2.U)\r\n\r\n  when(io.sel_imm === false.B && io.sel_a === false.B) {\r\n    mux3 := mux1 + mux2\r\n  }.elsewhen(io.sel_imm === false.B && io.sel_a === true.B) {\r\n    mux3 := 4.U + io.a\r\n  }.elsewhen(io.sel_imm === true.B && io.sel_a === false.B) {\r\n    mux3 := Cat(io.d_imm(13, 0), 0.U(2.W))\r\n  }.otherwise {\r\n    mux3 := 0.U\r\n  }\r\n\r\n  when(!io.normalOperation) {\r\n    addressReg := 0.U\r\n  }.otherwise {\r\n    addressReg := mux3\r\n  }\r\n}\r\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/faido/Documents/My%20Documents/ECE/Semester%206/Advanced%20Computer%20Architecture/Elidon/empty/register_file.scala","languageId":"scala","version":1,"text":"import chisel3._\r\n\r\nclass RegisterFile extends Module {\r\n  val io = IO(new Bundle {\r\n    val aAddr = Input(UInt(4.W))\r\n    val bAddr = Input(UInt(4.W))\r\n    val rdAddr = Input(UInt(4.W))\r\n    val wrAddr = Input(UInt(4.W))\r\n    val wrData = Input(UInt(16.W))\r\n    val wrEna = Input(Bool())\r\n    val rs1Data = Output(UInt(16.W))\r\n    val rs2Data = Output(UInt(16.W))\r\n  })\r\n\r\n  val regFile = SyncReadMem(16, Vec(2, UInt(16.W)))\r\n\r\n  when(io.wrEna) {\r\n    regFile.write(io.wrAddr, VecInit(Seq(io.wrData, 0.U)))\r\n  }\r\n\r\n  io.rs1Data := regFile.read(io.aAddr, 0.U)(0)\r\n  io.rs2Data := regFile.read(io.bAddr, 0.U)(0)\r\n}\r\n/**\r\n  *  The wrEna input controls whether a write occurs, and the wrData input specifies the data to be written. The rs1Addr, rs2Addr, and rdAddr inputs specify the addresses of the source and destination registers, and the rs1Data and rs2Data outputs provide the data from the source registers.\r\n  */"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/faido/Documents/My%20Documents/ECE/Semester%206/Advanced%20Computer%20Architecture/Elidon/empty/PC.scala","languageId":"scala","version":1,"text":"import chisel3._\r\n\r\nclass PC extends Module {\r\n  val io = IO(new Bundle {\r\n    // Clock input to pc\r\n    val clock = Input(Clock()) \r\n    // 1 > normal operation, 0 > resets PC\r\n    val normalOperation = Input(Bool()) \r\n    val sel_a     = Input(Bool()) //\r\n    val sel_imm   = Input(Bool())\r\n    val branch    = Input(Bool())\r\n    val a         = Input(UInt(16.W))\r\n    val d_imm     = Input(UInt(16.W))\r\n    val e_imm     = Input(UInt(16.W))\r\n    val pc_addr   = Input(UInt(16.W))\r\n    val addr      = Output(UInt(16.W))\r\n    val nextAddress = Output(UInt(16.W))\r\n  })\r\n\r\n  val adressReg   = RegInit(0.U(16.W))\r\n  val mux1  = Wire(UInt(16.W))\r\n  val mux2  = Wire(UInt(16.W))\r\n  val mux3  = Wire(UInt(16.W))\r\n\r\n  io.addr      := mux3\r\n  io.nextAddress := addresReg\r\n\r\n  mux1 := Mux(io.branch === false.B, addressReg, io.pc_addr)\r\n  mux2 := Mux(io.branch === false.B, 2.U, io.e_imm + 2.U)\r\n\r\n  when(io.sel_imm === false.B && io.sel_a === false.B) {\r\n    mux3 := mux1 + mux2\r\n  }.elsewhen(io.sel_imm === false.B && io.sel_a === true.B) {\r\n    mux3 := 4.U + io.a\r\n  }.elsewhen(io.sel_imm === true.B && io.sel_a === false.B) {\r\n    mux3 := Cat(io.d_imm(13, 0), 0.U(2.W))\r\n  }.otherwise {\r\n    mux3 := 0.U\r\n  }\r\n\r\n  when(!io.normalOperation) {\r\n    addressReg := 0.U\r\n  }.elsewhen (risingEdge(io.clock)) {\r\n    addressReg := mux3\r\n  }\r\n}\r\n\r\n\r\nclass PC2 extends Module {\r\n  val io = IO(new Bundle {\r\n    // 1 > normal operation, 0 > resets PC\r\n    val normalOperation = Input(Bool())\r\n    val jumpAdress = Input(Uint(16.W))\r\n    val jump = Input(Bool())\r\n    val nextAddress = Output(UInt(16.W))\r\n  })\r\n\r\n  val adressReg   = RegInit(0.U(16.W))\r\n  val mux1  = Wire(UInt(16.W))\r\n  val mux2  = Wire(UInt(16.W))\r\n  val mux3  = Wire(UInt(16.W))\r\n\r\n  io.addr      := mux3\r\n  io.nextAddress := addresReg\r\n\r\n  mux1 := Mux(io.branch === false.B, addressReg, io.pc_addr)\r\n  mux2 := Mux(io.branch === false.B, 2.U, io.e_imm + 2.U)\r\n\r\n  when(io.sel_imm === false.B && io.sel_a === false.B) {\r\n    mux3 := mux1 + mux2\r\n  }.elsewhen(io.sel_imm === false.B && io.sel_a === true.B) {\r\n    mux3 := 4.U + io.a\r\n  }.elsewhen(io.sel_imm === true.B && io.sel_a === false.B) {\r\n    mux3 := Cat(io.d_imm(13, 0), 0.U(2.W))\r\n  }.otherwise {\r\n    mux3 := 0.U\r\n  }\r\n\r\n  when(!io.normalOperation) {\r\n    addressReg := 0.U\r\n  }.otherwise {\r\n    addressReg := mux3\r\n  }\r\n}\r\n"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/faido/Documents/My%20Documents/ECE/Semester%206/Advanced%20Computer%20Architecture/Elidon/src/main/scala/Decode/DecodeStage.scala","languageId":"scala","version":1,"text":"import chisel3._\r\nimport chisel3.util._\r\n\r\nclass DecodeStage extends Module {\r\n  // val io = IO(new Bundle {\r\n  // })\r\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/faido/Documents/My%20Documents/ECE/Semester%206/Advanced%20Computer%20Architecture/Elidon/src/main/scala/Execute/ExecuteStage.scala","languageId":"scala","version":1,"text":"import chisel3._\r\nimport chisel3.util._\r\n\r\nclass ExecuteStage extends Module {\r\n  // val io = IO(new Bundle {\r\n  // })\r\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mEvaluating tasks: Compile / collectAnalyses[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/faido/Documents/My%20Documents/ECE/Semester%206/Advanced%20Computer%20Architecture/Elidon/src/main/scala/Memory/MemoryStage.scala","languageId":"scala","version":1,"text":"import chisel3._\r\nimport chisel3.util._\r\n\r\nclass MemoryStage extends Module {\r\n  // val io = IO(new Bundle {\r\n  // })\r\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mRunning task... Cancel: Signal, check cycles: false, forcegc: true[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/faido/Documents/My%20Documents/ECE/Semester%206/Advanced%20Computer%20Architecture/Elidon/src/main/scala/Memory/DataMemory.scala","languageId":"scala","version":1,"text":"import chisel3._\r\nimport chisel3.util._\r\n\r\nclass DataMemory extends Module {\r\n  val io = IO(new Bundle {\r\n    val readAdress = Input(UInt(16.W))\r\n    val writeAdress = Input(UInt(16.W))\r\n    val writeEnable = Input(Bool)\r\n    val writeValue = Input(UInt(16.W))\r\n    val readValue = Output(UInt(16.W))\r\n  })\r\n\r\n  val evenMem = ReadSyncMem(2^15, UInt(8.W))\r\n  val oddMem = ReadSyncMem(2^15, UInt(8.W))\r\n\r\n  class ReadBundle extends Bundle {\r\n    val msB = UInt(8.W)\r\n    val lsB = UInt(8.W)\r\n  }\r\n\r\n  val readBundle = Wire(new ReadBundle)\r\n  val readAdressOdd = WireDefault(io.readAdress(15,1))\r\n  val readAdressEven = Wire(UInt(15.W))\r\n\r\n  when(io.readAdress(0))) {\r\n    readAdressEven := readAdressOdd + 1.U\r\n    readBundle.msB := evenMem.read(readAdressOdd)\r\n    readBundle.lsB := oddMem.read(readAdressEven)\r\n  } .otherwise {\r\n    readAdressEven := readAdressOdd\r\n    readBundle.msB := evenMem.read(readAdressEven)\r\n    readBundle.lsB := oddMem.read(readAdressOdd)\r\n  }\r\n\r\n  class WriteBundle extends Bundle {\r\n    val even = UInt(8.W)\r\n    val odd = UInt(8.W)\r\n  }\r\n\r\n  val writeBundle = Wire(new WriteBundle)\r\n  val writeAdressOdd = WireDefault(io.writeAdress(15,1))\r\n  val writeAdressEven = Wire(UInt(15.W))\r\n\r\n  when(io.writeAdress & 1.U) {\r\n    writeAdressEven := writeAdressOdd + 1.U\r\n    writeBundle.even := io.writeValue(7, 0)\r\n    writeBundle.odd := io.writeValue(15, 8)\r\n  } .otherwise {\r\n    writeAdressEven := writeAdressOdd\r\n    writeBundle.even := io.writeValue(15, 8)\r\n    writeBundle.odd := io.writeValue(7, 0)\r\n  }\r\n\r\n  when(io.writeEnable) {\r\n    evenMem.write(writeBundle.even)\r\n    oddMem.write(writeBudnel.odd)\r\n  }\r\n\r\n  when(io.readAdress === io.writeAdress) {\r\n    io.readValue := io.writeValue\r\n  } .otherwise {\r\n    io.readValue := readBundle.asUInt\r\n  }\r\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/faido/Documents/My%20Documents/ECE/Semester%206/Advanced%20Computer%20Architecture/Elidon/src/main/scala/WriteBackStage/WriteBackStage.scala","languageId":"scala","version":1,"text":"import chisel3._\r\nimport chisel3.util._\r\n\r\nclass WriteBackStage extends Module {\r\n  // val io = IO(new Bundle {\r\n  // })\r\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/faido/Documents/My%20Documents/ECE/Semester%206/Advanced%20Computer%20Architecture/Elidon/src/main/scala/FetchStage/FetchStage.scala","languageId":"scala","version":1,"text":"import chisel3._\r\nimport chisel3.util._\r\n\r\nclass FetchStage extends Module {\r\n  // val io = IO(new Bundle {\r\n  // })\r\n  val instructionMem = Module(new Memory)\r\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/faido/Documents/My%20Documents/ECE/Semester%206/Advanced%20Computer%20Architecture/Elidon/src/main/scala/ExecuteStage/ExecuteStage.scala","languageId":"scala","version":1,"text":"import chisel3._\r\nimport chisel3.util._\r\n\r\nclass ExecuteStage extends Module {\r\n  // val io = IO(new Bundle {\r\n  // })\r\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/faido/Documents/My%20Documents/ECE/Semester%206/Advanced%20Computer%20Architecture/Elidon/src/main/scala/DecodeStage/DecodeStage.scala","languageId":"scala","version":1,"text":"import chisel3._\r\nimport chisel3.util._\r\n\r\nclass DecodeStage extends Module {\r\n  // val io = IO(new Bundle {\r\n  // })\r\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/faido/Documents/My%20Documents/ECE/Semester%206/Advanced%20Computer%20Architecture/Elidon/src/main/scala/Memory%20and%20IO/DataMemory.scala","languageId":"scala","version":261,"text":"import chisel3._\r\nimport chisel3.util._\r\n\r\nclass DataMemory extends Module {\r\n  val io = IO(new Bundle {\r\n    val data = new Bundle {\r\n      val readAdress = Input(UInt(16.W))\r\n      val writeAdress = Input(UInt(16.W))\r\n      val writeEnable = Input(Bool())\r\n      val writeValue = Input(UInt(16.W))\r\n      val readValue = Output(UInt(16.W))\r\n    }\r\n    \r\n    val leds = Output(UInt(16.W))\r\n    val displayValue = Output(UInt(16.W))\r\n    val switches = Input(UInt(16.W))\r\n  })\r\n\r\n  /********************************************************\r\n  * We split the memory into 2 parts because we want to handle\r\n  * 16 bit words, with byte adressing and also missaligned adresses\r\n  ********************************************************/\r\n  val evenMem = SyncReadMem(2^15, UInt(8.W))\r\n  val oddMem = SyncReadMem(2^15, UInt(8.W))\r\n\r\n  /********************************************************\r\n  * Read Functionality\r\n  ********************************************************/\r\n  class ReadBundle extends Bundle {\r\n    val msB = UInt(8.W)\r\n    val lsB = UInt(8.W)\r\n  }\r\n\r\n  val readBundle = Wire(new ReadBundle)\r\n  val readAdressOdd = WireDefault(io.data.readAdress(15,1))\r\n  val readAdressEven = Wire(UInt(15.W))\r\n\r\n  when(io.data.readAdress(0)) {\r\n    readAdressEven := readAdressOdd + 1.U\r\n    readBundle.msB := evenMem.read(readAdressOdd)\r\n    readBundle.lsB := oddMem.read(readAdressEven)\r\n  } .otherwise {\r\n    readAdressEven := readAdressOdd\r\n    readBundle.msB := evenMem.read(readAdressEven)\r\n    readBundle.lsB := oddMem.read(readAdressOdd)\r\n  }\r\n\r\n  class WriteBundle extends Bundle {\r\n    val even = UInt(8.W)\r\n    val odd = UInt(8.W)\r\n  }\r\n\r\n  /********************************************************\r\n  * Write Functionality\r\n  ********************************************************/\r\n  val writeBundle = Wire(new WriteBundle)\r\n  val writeAdressOdd = WireDefault(io.data.writeAdress(15,1))\r\n  val writeAdressEven = Wire(UInt(15.W))\r\n\r\n  when(io.data.writeAdress(0)) {\r\n    writeAdressEven := writeAdressOdd + 1.U\r\n    writeBundle.even := io.data.writeValue(7, 0)\r\n    writeBundle.odd := io.data.writeValue(15, 8)\r\n  } .otherwise {\r\n    writeAdressEven := writeAdressOdd\r\n    writeBundle.even := io.data.writeValue(15, 8)\r\n    writeBundle.odd := io.data.writeValue(7, 0)\r\n  }\r\n\r\n  when(io.data.writeEnable) {\r\n    evenMem.write(writeAdressEven, writeBundle.even)\r\n    oddMem.write(writeAdressOdd, writeBundle.odd)\r\n  }\r\n\r\n\r\n  /********************************************************\r\n  * Add IO functionality:\r\n  * Bytes 0, 1: LEDs\r\n  * Bytes 2, 3: Hex values of 7-segment display\r\n  * Bytes 4, 5: Input from switches\r\n  ********************************************************/\r\n  // Store the values in registers\r\n  val ledsReg = RegInit(0.U(16.W))\r\n  val displayValueReg = RegInit(0.U(16.W))\r\n  val switchesReg = RegNext(io.switches)\r\n\r\n  // Connect with IO\r\n  io.leds := ledsReg\r\n  io.displayValue := displayValueReg\r\n\r\n  // Set leds and displayValue on write\r\n  // They can only be set when adress is aligned\r\n  when(io.data.writeEnable) {\r\n    when(io.data.writeAdress === 0.U) {\r\n      ledsReg := io.data.writeValue\r\n    }\r\n    when(io.data.writeAdress === 2.U) {\r\n      displayValueReg := io.data.writeValue\r\n    }\r\n  } \r\n\r\n  /********************************************************\r\n  * Final read functionality\r\n  ********************************************************/\r\n\r\n  when(io.data.readAdress === 4.U) {  // Switches's value is only acessed when it's aligned:\r\n    io.data.readValue := switchesReg\r\n  } .elsewhen(io.data.readAdress === io.data.writeAdress) { // Forward value if adresses same\r\n    io.data.readValue := io.data.writeValue\r\n  } .otherwise {\r\n    io.data.readValue := readBundle.asUInt // Otherwise get it from memory\r\n  }\r\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/faido/Documents/My%20Documents/ECE/Semester%206/Advanced%20Computer%20Architecture/Elidon/src/main/scala/Fetch%20Stage/FetchStage.scala","languageId":"scala","version":55,"text":"import chisel3._\r\nimport chisel3.util._\r\n\r\nclass FetchStage extends Module {\r\n  // val io = IO(new Bundle {\r\n  // })\r\n  // val pcReg = Vec(RegInit()\r\n\r\n  // val instructionMemory = Vec()\r\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/faido/Documents/My%20Documents/ECE/Semester%206/Advanced%20Computer%20Architecture/Elidon/src/main/scala/Fetch%20Stage/InstructionMemory.scala","languageId":"scala","version":138,"text":"import chisel3._\r\nimport chisel3.util._\r\n\r\nclass InstructionMemory extends Module {\r\n  val io = IO(new Bundle {\r\n    val pc = Input(UInt(8.W))\r\n    val instruction = Output(UInt(16.W))\r\n  })\r\n\r\n  // Assemble and get instruction machine code\r\n  val instructionMem = RegInit(Vec())\r\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/faido/Documents/My%20Documents/ECE/Semester%206/Advanced%20Computer%20Architecture/Elidon/src/main/scala/Decode%20Stage/DecodeStage.scala","languageId":"scala","version":1,"text":"import chisel3._\r\nimport chisel3.util._\r\n\r\nclass DecodeStage extends Module {\r\n  // val io = IO(new Bundle {\r\n  // })\r\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/faido/Documents/My%20Documents/ECE/Semester%206/Advanced%20Computer%20Architecture/Elidon/src/main/scala/Memory%20Stage/MemoryStage.scala","languageId":"scala","version":180,"text":"import chisel3._\r\nimport chisel3.util._\r\n\r\nclass MemoryStage extends Module {\r\n  val io = IO(new Bundle {\r\n    val data = new Bundle {\r\n      val readAdress = Output(UInt(16.W))\r\n      val writeAdress = Output(UInt(16.W))\r\n      val writeEnable = Output(Bool())\r\n      val writeValue = Output(UInt(16.W))\r\n      val readValue = Input(UInt(16.W))\r\n    }\r\n  })\r\n  // Default values:\r\n  io.data.readAdress := WireDefault(0.U)\r\n  io.data.writeAdress := WireDefault(0.U)\r\n  io.data.writeEnable := WireDefault(false.B)\r\n  io.data.writeValue := WireDefault(0.U)\r\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/faido/Documents/My%20Documents/ECE/Semester%206/Advanced%20Computer%20Architecture/Elidon/src/main/scala/Write%20Back%20Stage/WriteBackStage.scala","languageId":"scala","version":1,"text":"import chisel3._\r\nimport chisel3.util._\r\n\r\nclass WriteBackStage extends Module {\r\n  // val io = IO(new Bundle {\r\n  // })\r\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/faido/Documents/My%20Documents/ECE/Semester%206/Advanced%20Computer%20Architecture/Elidon/src/main/scala/Memory%20and%20IO/DisplayMultiplexer.scala","languageId":"scala","version":142,"text":"import chisel3._\r\nimport chisel3.util._\r\n\r\nclass DisplayMultiplexer() extends Module {\r\n  val io = IO(new Bundle {\r\n    val value = Input(UInt(16.W))\r\n    val display = new Bundle {\r\n      val segments = Output(UInt(7.W))\r\n      val selector = Output(UInt(4.W))\r\n    }\r\n  })\r\n\r\n  val sevSeg = WireDefault(\"b1111111\".U(7.W))\r\n  val select = WireDefault(\"b0001\".U(4.W))\r\n\r\n  // val countMax = clockFrequency / tickFrequency - 1;\r\n  val countMax = 99999.U(17.W)\r\n  val countReg = RegInit(0.U(17.W))\r\n  countReg := countReg + 1.U\r\n  val tick = countReg === countMax\r\n\r\n  when (tick) {\r\n    countReg := 0.U\r\n  }\r\n\r\n  val digitReg = RegInit(0.U(2.W))\r\n  digitReg := digitReg + tick\r\n\r\n  val sevenSegDec = Module(new SevenSegDec())\r\n\r\n  sevenSegDec.io.in := 0.U(4.W);\r\n\r\n  switch(digitReg) {\r\n    is(0.U) {\r\n      sevenSegDec.io.in := io.value(3, 0)\r\n      select := \"b0001\".U\r\n    }\r\n    is(1.U) {\r\n      sevenSegDec.io.in := io.value(7, 4)\r\n      select := \"b0010\".U\r\n    }\r\n    is(2.U) {\r\n      sevenSegDec.io.in := io.value(11, 8)\r\n      select := \"b0100\".U\r\n    }\r\n    is(3.U) {\r\n      sevenSegDec.io.in := io.value(15, 12)\r\n      select := \"b1000\".U\r\n    }\r\n  }\r\n\r\n  sevSeg := sevenSegDec.io.out\r\n\r\n  io.display.segments := ~sevSeg\r\n  io.display.selector := ~select\r\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0mUnhandled notification received: textDocument/didOpen: JsonRpcNotificationMessage(2.0, textDocument/didOpen, {"textDocument":{"uri":"file:///c%3A/Users/faido/Documents/My%20Documents/ECE/Semester%206/Advanced%20Computer%20Architecture/Elidon/src/main/scala/Fetch%20Stage/Assembler.scala","languageId":"scala","version":1,"text":"import scala.io.Source\r\n\r\nobject Assembler {\r\n\r\n  val prog = Array[Int](\r\n    0xc7, 0x12, // ldi 0x12\r\n    0xc0, 0x34, // addi 0x34\r\n    0xc1, 0x12, // subi 0x12\r\n    0xc4, 0xf0, // andi 0xf0\r\n    0xc5, 0x03, // ori 0x03\r\n    0xc6, 0xff, // xori 0xff\r\n    0x82, // st r2\r\n    0x00)\r\n\r\n  // collect destination addresses in first pass\r\n  val symbols = collection.mutable.Map[String, Int]()\r\n\r\n  def getProgramFix() = prog\r\n\r\n  def getProgram(prog: String) = assemble(prog)\r\n\r\n  def assemble(prog: String): Array[Int] = {\r\n    assemble(prog, false)\r\n    assemble(prog, true)\r\n  }\r\n\r\n  def assemble(prog: String, pass2: Boolean): Array[Int] = {\r\n\r\n    val source = Source.fromFile(prog)\r\n    var program = List[Int]()\r\n    var pc = 0\r\n\r\n    def toInt(s: String): Int = {\r\n      if (s.startsWith(\"0x\")) {\r\n        Integer.parseInt(s.substring(2), 16)\r\n      } else {\r\n        Integer.parseInt(s)\r\n      }\r\n    }\r\n\r\n    def regNumber(s: String): Int = {\r\n      assert(s.startsWith(\"r\"))\r\n      s.substring(1).toInt\r\n    }\r\n\r\n    def regIndirect(s: String): Int = {\r\n      assert(s.startsWith(\"(r\"))\r\n      assert(s.endsWith(\")\"))\r\n      s.substring(2, s.length - 1).toInt\r\n    }\r\n\r\n    for (line <- source.getLines()) {\r\n      if (!pass2) println(line)\r\n      val tokens = line.trim.split(\" \")\r\n      // println(s\"length: ${tokens.length}\")\r\n      // tokens.foreach(println)\r\n      val Pattern = \"(.*:)\".r\r\n      val instr = tokens(0) match {\r\n        case \"#\" => // comment\r\n        case Pattern(l) => if (!pass2) symbols += (l.substring(0, l.length - 1) -> pc)\r\n        case \"add\" => 0x00 + regNumber(tokens(1))\r\n        case \"sub\" => 0x10 + regNumber(tokens(1))\r\n        case \"adc\" => 0x20 + regNumber(tokens(1))\r\n        case \"sbb\" => 0x30 + regNumber(tokens(1))\r\n        case \"and\" => 0x40 + regNumber(tokens(1))\r\n        case \"or\" => 0x50 + regNumber(tokens(1))\r\n        case \"xor\" => 0x60 + regNumber(tokens(1))\r\n        case \"ld\" => 0x70 + regNumber(tokens(1))\r\n        case \"addi\" => (0xc0, toInt(tokens(1)))\r\n        case \"subi\" => (0xc1, toInt(tokens(1)))\r\n        case \"adci\" => (0xc2, toInt(tokens(1)))\r\n        case \"sbbi\" => (0xc3, toInt(tokens(1)))\r\n        case \"andi\" => (0xc4, toInt(tokens(1)))\r\n        case \"ori\" => (0xc5, toInt(tokens(1)))\r\n        case \"xori\" => (0xc6, toInt(tokens(1)))\r\n        case \"ldi\" => (0xc7, toInt(tokens(1)))\r\n        case \"st\" => 0x80 + regNumber(tokens(1))\r\n        case \"ldind\" => 0xa0 + regIndirect(tokens(1))\r\n        case \"stind\" => 0xb0 + regIndirect(tokens(1))\r\n        case \"br\" => (0xd0, if (pass2) symbols(tokens(1)) else 0)\r\n        case \"brz\" => (0xd2, if (pass2) symbols(tokens(1)) else 0)\r\n        case \"brnz\" => (0xd3, if (pass2) symbols(tokens(1)) else 0)\r\n        case \"io\" => 0xf0 + toInt(tokens(1))\r\n        case \"exit\" => (0xff)\r\n        case \"\" => // println(\"Empty line\")\r\n        case t: String => throw new Exception(\"Assembler error: unknown instruction\")\r\n        case _ => throw new Exception(\"Assembler error\")\r\n      }\r\n      // println(instr)\r\n\r\n      instr match {\r\n        case (a: Int) => {\r\n          program = a :: program\r\n          pc += 1\r\n        }\r\n        case (a: Int, b: Int) => {\r\n          program = a :: program\r\n          program = b :: program\r\n          pc += 2\r\n        }\r\n        case _ => // println(\"Something else\")\r\n      }\r\n    }\r\n    val finalProg = program.reverse.toArray\r\n    if (!pass2) {\r\n      println(s\"The program:\")\r\n      finalProg.foreach(printf(\"0x%02x \", _))\r\n      println()\r\n    }\r\n    finalProg\r\n  }\r\n}"}})[0m
[0m[[0m[0mdebug[0m] [0m[0manalysis location (C:\Users\faido\Documents\My Documents\ECE\Semester 6\Advanced Computer Architecture\Elidon\target\scala-2.12\zinc\inc_compile_2.12.zip,true)[0m
[0m[[0m[32msuccess[0m] [0m[0mTotal time: 2 s, completed 2 May 2023, 15:34:38[0m
[0m[[0m[0mdebug[0m] [0m[0munmatched Done event for requestId None: None[0m
[0m[[0m[0mdebug[0m] [0m[0m> Exec(shell, None, None)[0m
